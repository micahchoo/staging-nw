/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HtmlLocalSrcPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var HtmlLocalSrcPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.enableLog = false;
    this.log = this.enableLog ? console.log : () => {
    };
    /*
    scroll 子函数
     */
    this.scrollLines = async (element) => {
      let rect = element.getBoundingClientRect();
      const height = rect.height;
      const clientHeight = Math.round(element.clientHeight);
      const scrollTop = Math.round(element.scrollTop);
      const lineHeight = height / clientHeight;
      const scrollLines = Math.round(scrollTop / lineHeight);
      this.log("scrollHeight ", scrollTop % clientHeight - clientHeight / 4 < 0);
      if (scrollTop % clientHeight - clientHeight / 4 < 0) {
        this.log("in Scroll");
        this.useProcessMarkdown();
      }
      this.log("You scrollTop " + scrollTop + "  ,Height =" + clientHeight + ", clientHeight " + clientHeight + " lines.");
      return scrollLines;
    };
  }
  onload() {
    this.registerMarkdownPostProcessor((element, ctx) => {
      this.processMarkdown(element);
    });
    this.processView();
    this.registerMarkdownPostProcessor(this.modifyHTML.bind(this));
    this.registerEvent(this.app.workspace.on("file-open", this.processView.bind(this)));
    this.registerEvent(this.app.workspace.on("editor-change", this.useProcessMarkdown.bind(this)));
  }
  /*
  主要函数
   */
  processView() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    const file = activeView == null ? void 0 : activeView.file;
    if (file == null)
      return;
    this.log("\u6587\u4EF6\u5DF2\u6253\u5F00", file.path);
    this.useProcessMarkdown();
    if (activeView instanceof import_obsidian.MarkdownView) {
      this.scroll_toUpdateView(activeView);
    }
    this.log(import_obsidian.editorLivePreviewField);
    this.log("end");
  }
  processMarkdown(element) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    const activeFile = activeView == null ? void 0 : activeView.file;
    if (activeFile) {
      const targetLinks = Array.from(element.getElementsByTagName("img")).filter(
        (link) => {
          return link.src.lastIndexOf(":") === 3;
        }
      );
      let activePath = this.app.vault.getResourcePath(activeFile);
      this.log(activeView == null ? void 0 : activeView.getEphemeralState());
      this.log(this.app.workspace);
      this.log(activePath);
      activePath = activePath ? activePath.substring(0, activePath.lastIndexOf("/")) : "";
      for (const link of targetLinks) {
        let cleanLink = link.src.replace("app://obsidian.md/", "");
        link.src = activePath + "/" + cleanLink;
      }
    }
  }
  useProcessMarkdown() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    this.log("activeView  ", activeView);
    const element = activeView == null ? void 0 : activeView.contentEl;
    if (element) {
      this.processMarkdown(element);
    }
  }
  modifyHTML(el, ctx) {
    this.log("Markdown rendering completed:", ctx.sourcePath);
  }
  scroll_toUpdateView(activeView) {
    let div = activeView.containerEl.querySelector(".cm-scroller");
    this.log(div);
    this.registerDomEvent(div, "scroll", (event) => {
      this.scrollLines(div);
      this.log("Editor Scrolled:   pixels vertically and pixels horizontally.");
    });
  }
};


/* nosourcemap */